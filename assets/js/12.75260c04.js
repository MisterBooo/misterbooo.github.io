(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{398:function(t,s,n){"use strict";n.r(s);var a=n(54),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"leetcode-160、相交链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-160、相交链表"}},[t._v("#")]),t._v(" LeetCode 160、相交链表")]),t._v(" "),n("h2",{attrs:{id:"一、题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),n("strong",[t._v("一、题目描述")])]),t._v(" "),n("p",[t._v("编写一个程序，找到两个单链表相交的起始节点。")]),t._v(" "),n("p",[t._v("如下面的两个链表：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109399",alt:"img"}})]),t._v(" "),n("p",[t._v("在节点 c1 开始相交。")]),t._v(" "),n("p",[n("strong",[t._v("注意：")])]),t._v(" "),n("ul",[n("li",[t._v("如果两个链表没有交点，返回 null。")]),t._v(" "),n("li",[t._v("在返回结果后，两个链表仍须保持原有的结构。")]),t._v(" "),n("li",[t._v("可假定整个链表结构中没有循环。")]),t._v(" "),n("li",[t._v("程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。")])]),t._v(" "),n("h2",{attrs:{id:"二、题目解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("二、题目解析")])]),t._v(" "),n("h4",{attrs:{id:"_1、模拟"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、模拟"}},[t._v("#")]),t._v(" "),n("strong",[t._v("1、模拟")])]),t._v(" "),n("p",[t._v("首先假设 A 、B 两个链表是有"),n("strong",[t._v("相交节点")]),t._v("的情况。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109004.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.002")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109696.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.003")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109449.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.004")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109478.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.005")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://r07na4yqwor.feishu.cn/space/api/box/stream/download/asynccode/?code=MjMzZDI2MTIxOTAwZmYxN2RmNjg2MTg0MzYwYzA2ZDlfVVBZV3dRWGx3Q3BBSnBPenZKdjIzVTJtSjJyV04zanNfVG9rZW46U2VISWJ4SlBab2hzNXB4RkFsbGNTcWtObmZmXzE2ODYyODAxOTE6MTY4NjI4Mzc5MV9WNA",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.006")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091109067.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.007")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110369.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.008")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110310.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.009")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110844.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.010")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110814.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.011")]),t._v(" "),n("p",[t._v("再假设 A 、B 两个链表是"),n("strong",[t._v("没有相交节点")]),t._v("的情况。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110941.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.012")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110496.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.013")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110540.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.014")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306091110734.(null)",alt:"img"}})]),t._v(" "),n("p",[t._v("相交链表.015")]),t._v(" "),n("h4",{attrs:{id:"_2、规律"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、规律"}},[t._v("#")]),t._v(" "),n("strong",[t._v("2、规律")])]),t._v(" "),n("p",[t._v("也就是说，无论 A、B 两个链表是否有相交点，最终都会指向一个相同的节点，要么是它们的公共尾部，要么是 NULL。")]),t._v(" "),n("p",[t._v("让指针 "),n("code",[t._v("pointA")]),t._v(" 和 "),n("code",[t._v("pointB")]),t._v(" 分别指向链表 A 和链表 B 的头结点，之后两个指针分别以步幅为 1 的速度向链表的尾部遍历。")]),t._v(" "),n("ul",[n("li",[t._v("当指针 "),n("code",[t._v("pointA")]),t._v(" 遍历到链表 A 的尾节点时，此时指针 "),n("code",[t._v("pointA")]),t._v(" 走了 a 个节点，将指针 "),n("code",[t._v("pointA")]),t._v(" 指向链表 B 的头部，继续向后遍历，直至走到 "),n("code",[t._v("c1")]),t._v("，此时指针 "),n("code",[t._v("pointA")]),t._v(" 总共走了 "),n("code",[t._v("a + ( b - c )")]),t._v(" 步。")]),t._v(" "),n("li",[t._v("当指针 "),n("code",[t._v("pointB")]),t._v(" 遍历到链表 B 的尾节点时，此时指针 "),n("code",[t._v("pointB")]),t._v(" 走了 b 个节点，将指针 "),n("code",[t._v("pointB")]),t._v(" 指向链表 A 的头部，继续向后遍历，直至走到 "),n("code",[t._v("c1")]),t._v("，此时指针 "),n("code",[t._v("pointB")]),t._v(" 总共走了 "),n("code",[t._v("b + ( a - c )")]),t._v(" 步。")])]),t._v(" "),n("p",[t._v("根据数学知识，"),n("code",[t._v("a + ( b - c ) = b + ( a - c )")]),t._v("   ，如果 c > 0，表明两链表有公共尾部， "),n("code",[t._v("c1")]),t._v(" 存在，两两链表同时到达 "),n("code",[t._v("c1")]),t._v("；如果 c = 0，表明两链表没有公共尾部，指针 "),n("code",[t._v("pointA")]),t._v(" 和 "),n("code",[t._v("pointB")]),t._v(" 都指向 "),n("code",[t._v("NULL")]),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"三、参考代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("三、参考代码")])]),t._v(" "),n("h3",{attrs:{id:"_1、java-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("1、Java 代码")])]),t._v(" "),n("div",{staticClass:"language-Java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIntersectionNode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" headA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" headB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 边界判断")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("headA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" headB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个指针 pointA，指向链表 A 的头节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个指针 pointB，指向链表 B 的头节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的之和减一")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pointA 和 pointB 都会同时指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么 pointA 移动了 7 + 11 - 1 次之后，会指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pointB 移动了 7 + 11 - 1  次之后，也指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个时候就跳出了循环")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" pointB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 ")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指针 pointA 跳转到链表 B 上  ")]),t._v("\n                pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 否则的话 pointA 不断的向后移动")]),t._v("\n                pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pointA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n             "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 ")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指针 pointA 跳转到链表 B 上  ")]),t._v("\n                pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 否则的话 pointB 不断的向后移动")]),t._v("\n                pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pointB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、此时，headA 和 headB 不相交，那么 pointA 和 pointB 均为 null，也返回任意一个均可")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" pointA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"_2、-c-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、-c-代码"}},[t._v("#")]),t._v(" **2、**"),n("strong",[t._v("C++")]),t._v(" "),n("strong",[t._v("代码")])]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 登录 AlgoMooc 官网获取更多算法图解\n// https://www.algomooc.com\n// 作者：程序员吴师兄\n// 代码有看不懂的地方一定要私聊咨询吴师兄呀\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // 边界判断\n        if (headA == NULL || headB == NULL) return NULL;\n        \n        // 设置一个指针 pointA，指向链表 A 的头节点\n        ListNode *pointA = headA;\n        \n        // 设置一个指针 pointB，指向链表 B 的头节点\n        ListNode *pointB = headB;\n\n        // 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点\n        // 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的之和减一\n        // pointA 和 pointB 都会同时指向 null\n        // 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交\n        // 那么 pointA 移动了 7 + 11 - 1 次之后，会指向 null\n        // pointB 移动了 7 + 11 - 1  次之后，也指向 null\n        // 这个时候就跳出了循环\n        while (pointA != pointB) {\n            // 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 \n            if( pointA == NULL){\n                // 指针 pointA 跳转到链表 B 上  \n                pointA = headB;\n            }else{\n                // 否则的话 pointA 不断的向后移动\n                pointA = pointA->next;\n            }\n\n             // 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 \n            if( pointB == NULL){\n                // 指针 pointA 跳转到链表 B 上  \n                pointB = headA;\n            }else{\n                // 否则的话 pointB 不断的向后移动\n                pointB = pointB->next;\n            }\n        }\n        \n        // 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可\n        // 2、此时，headA 和 headB 不相交，那么 pointA 和 pointB 均为 null，也返回任意一个均可\n        return pointA;\n    }\n};\n")])])]),n("h3",{attrs:{id:"_3、python-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("3、Python 代码")])]),t._v(" "),n("div",{staticClass:"language-Python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIntersectionNode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" headA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ListNode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" headB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ListNode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" ListNode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 边界判断")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" headA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("or")]),t._v(" headB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个指针 pointA，指向链表 A 的头节点")]),t._v("\n        pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headA\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个指针 pointB，指向链表 B 的头节点")]),t._v("\n        pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headB\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的之和减一")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# pointA 和 pointB 都会同时指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么 pointA 移动了 7 + 11 - 1 次之后，会指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# pointB 移动了 7 + 11 - 1  次之后，也指向 null")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这个时候就跳出了循环")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" pointB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 ")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指针 pointA 跳转到链表 B 上  ")]),t._v("\n                pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headB\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 否则的话 pointA 不断的向后移动")]),t._v("\n                pointA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pointA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 ")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 指针 pointA 跳转到链表 B 上  ")]),t._v("\n                pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" headA\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 否则的话 pointB 不断的向后移动")]),t._v("\n                pointB "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pointB"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2、此时，headA 和 headB 不相交，那么 pointA 和 pointB 均为 null，也返回任意一个均可")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" pointA\n")])])]),n("h2",{attrs:{id:"四、复杂度分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、复杂度分析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("四、复杂度分析")])]),t._v(" "),n("p",[t._v("时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。")]),t._v(" "),n("p",[t._v("空间复杂度：O(1)。")])])}),[],!1,null,null,null);s.default=e.exports}}]);