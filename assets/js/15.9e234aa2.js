(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{400:function(t,a,s){"use strict";s.r(a);var n=s(54),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"leetcode-24、两两交换链表中的节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-24、两两交换链表中的节点"}},[t._v("#")]),t._v(" LeetCode 24、两两交换链表中的节点")]),t._v(" "),s("h2",{attrs:{id:"一、题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),s("strong",[t._v("一、题目描述")])]),t._v(" "),s("p",[t._v("给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。"),s("strong",[t._v("你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("示例 1：")])]),t._v(" "),s("div",{staticClass:"language-Plain extra-class"},[s("pre",{pre:!0,attrs:{class:"language-plain"}},[s("code",[t._v("输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n")])])]),s("p",[s("strong",[t._v("示例 2：")])]),t._v(" "),s("div",{staticClass:"language-Plain extra-class"},[s("pre",{pre:!0,attrs:{class:"language-plain"}},[s("code",[t._v("输入：head = []\n输出：[]\n")])])]),s("p",[s("strong",[t._v("示例 3：")])]),t._v(" "),s("div",{staticClass:"language-Plain extra-class"},[s("pre",{pre:!0,attrs:{class:"language-plain"}},[s("code",[t._v("输入：head = [1]\n输出：[1]\n")])])]),s("p",[s("strong",[t._v("提示：")])]),t._v(" "),s("ul",[s("li",[t._v("链表中节点的数目在范围 [0, 100] 内")]),t._v(" "),s("li",[t._v("0 <= Node.val <= 100")])]),t._v(" "),s("h2",{attrs:{id:"二、题目解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),s("strong",[t._v("二、题目解析")])]),t._v(" "),s("h2",{attrs:{id:"三、参考代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("三、参考代码")])]),t._v(" "),s("h3",{attrs:{id:"_1、java-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1、Java 代码")])]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 两两交换链表中的节点（LeetCode 24）： https://leetcode.cn/problems/swap-nodes-in-pairs/ ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapPairs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 寻找递归终止条件")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、head 指向的结点为 null ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、head 指向的结点的下一个结点为 null ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在这两种情况下，一个节点或者空节点无论怎么交换操作，都是原来的 head")]),t._v("\n      \t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" head "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       \t\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \t\t\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点或者最后两个节点")]),t._v("\n    \t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" subHead "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapPairs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对于 head 这个节点来说，它是和它相邻的右边这个节点进行交换操作")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以先要保存这个节点，并且经过上述递归终止条件的判断，head.next 是必然存在的")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" headNext "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// head 原来是指向 headNext")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 交换之后")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// headNext 指向 head")]),t._v("\n    \t\theadNext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// headNext 原来是指向 subHead")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 现在需要让 head 指向 subHead")]),t._v("\n    \t\thead"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" subHead"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 交换之后，原来的第二位的那个节点 headNext 变成了第一位")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把它返回就行")]),t._v("\n    \t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" headNext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_2、c-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、c-代码"}},[t._v("#")]),t._v(" **2、C++ **代码")]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        // 寻找递归终止条件\n        // 1、head 指向的结点为 null \n        // 2、head 指向的结点的下一个结点为 null \n        // 在这两种情况下，一个节点或者空节点无论怎么交换操作，都是原来的 head\n       if( head == NULL || head->next == NULL) {\n          \t\treturn head;\n       }\n  \n        // 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点或者最后两个节点\n      \tListNode *subHead = swapPairs(head->next->next);\n\n        // 对于 head 这个节点来说，它是和它相邻的右边这个节点进行交换操作\n        // 所以先要保存这个节点，并且经过上述递归终止条件的判断，head.next 是必然存在的\n        ListNode *headNext = head->next;\n\n        // head 原来是指向 headNext\n        // 交换之后\n        // headNext 指向 head\n      \theadNext->next = head;\n  \n        // headNext 原来是指向 subHead\n        // 现在需要让 head 指向 subHead\n      \thead->next = subHead;\n  \n        // 交换之后，原来的第二位的那个节点 headNext 变成了第一位\n        // 把它返回就行\n      \treturn headNext;\n        \n    }\n};\n")])])]),s("h3",{attrs:{id:"_3、python-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3、Python 代码")])]),t._v(" "),s("div",{staticClass:"language-Python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapPairs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ListNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" ListNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 寻找递归终止条件")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1、head 指向的结点为 null ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2、head 指向的结点的下一个结点为 null ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在这两种情况下，一个节点或者空节点无论怎么交换操作，都是原来的 head")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" head "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("or")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" head\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点或者最后两个节点")]),t._v("\n        subHead "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("swapPairs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 对于 head 这个节点来说，它是和它相邻的右边这个节点进行交换操作")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 所以先要保存这个节点，并且经过上述递归终止条件的判断，head.next 是必然存在的")]),t._v("\n        headNext "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# head 原来是指向 headNext")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 交换之后")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# headNext 指向 head")]),t._v("\n        headNext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head\n  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# headNext 原来是指向 subHead")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 现在需要让 head 指向 subHead")]),t._v("\n        head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" subHead\n  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 交换之后，原来的第二位的那个节点 headNext 变成了第一位")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把它返回就行")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" headNext\n")])])]),s("h2",{attrs:{id:"复杂度分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[t._v("#")]),t._v(" "),s("strong",[t._v("复杂度分析")])]),t._v(" "),s("p",[t._v("时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。")]),t._v(" "),s("p",[t._v("空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。")])])}),[],!1,null,null,null);a.default=e.exports}}]);