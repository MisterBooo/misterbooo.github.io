(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{556:function(t,n,s){"use strict";s.r(n);var a=s(54),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"leetcode-105、从前序与中序遍历序列构造二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-105、从前序与中序遍历序列构造二叉树"}},[t._v("#")]),t._v(" LeetCode 105、从前序与中序遍历序列构造二叉树")]),t._v(" "),s("h2",{attrs:{id:"一、题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),s("strong",[t._v("一、题目描述")])]),t._v(" "),s("p",[t._v("给定一棵树的前序遍历 "),s("code",[t._v("preorder")]),t._v(" 与中序遍历  "),s("code",[t._v("inorder")]),t._v("。请构造二叉树并返回其根节点。")]),t._v(" "),s("h2",{attrs:{id:"二、题目解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),s("strong",[t._v("二、题目解析")])]),t._v(" "),s("h2",{attrs:{id:"三、参考代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("三、参考代码")])]),t._v(" "),s("h3",{attrs:{id:"_1、java-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1、Java 代码")])]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从前序与中序遍历序列构造二叉树（ LeetCode 105 ）:https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("buildTree")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 题目中说 preorder 和 inorder 均无重复元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过哈希表把中序遍历序列中的值和顺序建立映射关系")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过 for 循环，遍历完中序遍历序列中的所有元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以中序序列中的元素值 inorder[i] 作为 key")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以位置 i 作为 value")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 存放到哈希表中")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如中序遍历序列中的元素是 [   A  ,   D  ,   E  ,   F  ,   G  ,   H  ,   M  ,   Z  ]")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么这个哈希表就是以下的样子")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | 索引 | 位置  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | A | 0  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | D | 1  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | E | 2  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | F | 3  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | G | 4  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | H | 5  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | M | 6  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// | Z | 7  |            ")]),t._v("\n             map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下面开始构建二叉树")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把前序遍历序列中的第一个元素 preorder[0] 作为二叉树的根节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 因为任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 继续遍历前序遍历序列中的其它元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把当前遍历的元素构造为一个二叉树的节点")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把构造的节点插入到以 root 为根节点的二叉树中")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当 preorder 中所有元素都构造并且插入完毕之后")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 二叉树就完成了构建")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// root : 二叉树的根节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// node : 待插入的节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// map : 节点值和中序遍历序列位置的映射")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当 root 和 node 指向的节点相同时，跳出循环")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果 node 的中序遍历序列位置小于 root 的中序遍历序列位置")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 说明 node 应该在 root 的左子树中")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果此时 root 没有左子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么就把 node 设置为 root 的左子树")]),t._v("\n                        root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、如果之前 root 没有左子树，那么通过上面的代码，就设置好了 root 的左子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也就是说 node 是 root 的一个叶子节点，完成了插入操作")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把 root 指向 root.left 后，root 为 node，跳出了循环")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、如果之前 root 已经有左子树，那么就不能直接把 node 插入到 root 的左子树上")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要判断应该把 node 插入到 root 左子树上的孩子节点的那个位置上")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如现在的 root 是这个样子，node 为 A")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        G")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       /")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//      D")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     /  \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//    ①   ②")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// root 已经有左子树 D 了，所以 node 应该考虑插入到 D 中的 ① 还是 ② 上面")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以，把 root 指向 root.left ，继续遍历 root 的左子树的情况")]),t._v("\n                    root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    \n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果 node 的中序遍历序列位置大于 root 的中序遍历序列位置")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 说明 node 应该在 root 的右子树中")]),t._v("\n                    \n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果此时 root 没有右子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么就把 node 设置为 root 的右子树")]),t._v("\n                        root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把 root 指向 root.right ，继续遍历 root 的右子树的情况")]),t._v("\n                    root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    \n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_2、-c-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、-c-代码"}},[t._v("#")]),t._v(" **2、**"),s("strong",[t._v("C++")]),t._v(" "),s("strong",[t._v("代码")])]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 登录 AlgoMooc 官网获取更多算法图解\n// https://www.algomooc.com\n// 作者：程序员吴师兄\n// 代码有看不懂的地方一定要私聊咨询吴师兄呀\n// 从前序与中序遍历序列构造二叉树（ LeetCode 105 ）:https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal\nclass Solution {\n\n    // 题目中说 preorder 和 inorder 均无重复元素\n    // 通过哈希表把中序遍历序列中的值和顺序建立映射关系\n    unordered_map<int, int> map;\n\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n\n        // 通过 for 循环，遍历完中序遍历序列中的所有元素\n        for (int i = 0; i < inorder.size(); i++) {\n             // 以中序序列中的元素值 inorder[i] 作为 key\n             // 以位置 i 作为 value\n             // 存放到哈希表中\n             // 比如中序遍历序列中的元素是 [   A  ,   D  ,   E  ,   F  ,   G  ,   H  ,   M  ,   Z  ]\n             // 那么这个哈希表就是以下的样子\n             // | 索引 | 位置  |\n             // | A | 0  |\n             // | D | 1  |\n             // | E | 2  | \n             // | F | 3  | \n             // | G | 4  | \n             // | H | 5  | \n             // | M | 6  | \n             // | Z | 7  |            \n             map[inorder[i]] =  i;\n        }\n\n        // 下面开始构建二叉树\n        // 把前序遍历序列中的第一个元素 preorder[0] 作为二叉树的根节点\n        // 因为任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点\n        TreeNode *root = new TreeNode(preorder[0]);\n\n        // 继续遍历前序遍历序列中的其它元素\n        for(int i = 1 ; i < preorder.size() ; i++){\n\n            // 把当前遍历的元素构造为一个二叉树的节点\n            TreeNode *node = new TreeNode(preorder[i]);\n\n            // 把构造的节点插入到以 root 为根节点的二叉树中\n            insertNode(root,node);\n\n        }\n\n        // 当 preorder 中所有元素都构造并且插入完毕之后\n        // 二叉树就完成了构建\n        return root;\n    }\n\n    // root : 二叉树的根节点\n    // node : 待插入的节点\nprivate:\n       void insertNode(TreeNode *root,TreeNode *node){\n\n            // 当 root 和 node 指向的节点相同时，跳出循环\n            while(root != node){\n\n                // 如果 node 的中序遍历序列位置小于 root 的中序遍历序列位置\n                // 说明 node 应该在 root 的左子树中\n                if(map[node->val] < map[root->val]){\n\n                    // 如果此时 root 没有左子树\n                    if(root->left == NULL){\n                        // 那么就把 node 设置为 root 的左子树\n                        root->left = node;\n                    }\n\n                    // 1、如果之前 root 没有左子树，那么通过上面的代码，就设置好了 root 的左子树\n                    // 也就是说 node 是 root 的一个叶子节点，完成了插入操作\n                    // 把 root 指向 root.left 后，root 为 node，跳出了循环\n\n                    // 2、如果之前 root 已经有左子树，那么就不能直接把 node 插入到 root 的左子树上\n                    // 需要判断应该把 node 插入到 root 左子树上的孩子节点的那个位置上\n                    // 比如现在的 root 是这个样子，node 为 A\n                    //        G\n                    //       /\n                    //      D\n                    //     /  \\\n                    //    ①   ②\n                    // root 已经有左子树 D 了，所以 node 应该考虑插入到 D 中的 ① 还是 ② 上面\n                    // 所以，把 root 指向 root.left ，继续遍历 root 的左子树的情况\n                    root = root->left;\n\n\n                }else{\n\n                    // 如果 node 的中序遍历序列位置大于 root 的中序遍历序列位置\n                    // 说明 node 应该在 root 的右子树中\n\n                    // 如果此时 root 没有右子树\n                    if(root->right == NULL){\n                        // 那么就把 node 设置为 root 的右子树\n                        root->right = node;\n                    }\n\n                    // 把 root 指向 root.right ，继续遍历 root 的右子树的情况\n                    root = root->right;\n\n                }\n\n            }\n    }\n};\n")])])]),s("h3",{attrs:{id:"_3、python-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3、Python 代码")])]),t._v(" "),s("div",{staticClass:"language-Python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# https://www.algomooc.com")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 作者：程序员吴师兄")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 从前序与中序遍历序列构造二叉树（ LeetCode 105 ）:https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("buildTree")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" List"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" List"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 题目中说 preorder 和 inorder 均无重复元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 通过哈希表把中序遍历序列中的值和顺序建立映射关系")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 通过 for 循环，遍历完中序遍历序列中的所有元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("dict")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 以中序序列中的元素值 inorder[i] 作为 key")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 以位置 i 作为 value")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 存放到哈希表中")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 比如中序遍历序列中的元素是 [   A  ,   D  ,   E  ,   F  ,   G  ,   H  ,   M  ,   Z  ]")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么这个哈希表就是以下的样子")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | 索引 | 位置  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | A | 0  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | D | 1  |")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | E | 2  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | F | 3  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | G | 4  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | H | 5  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | M | 6  | ")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# | Z | 7  |  ")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  i\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 下面开始构建二叉树")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把前序遍历序列中的第一个元素 preorder[0] 作为二叉树的根节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 因为任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点")]),t._v("\n        root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 继续遍历前序遍历序列中的其它元素")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把当前遍历的元素构造为一个二叉树的节点")]),t._v("\n            node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把构造的节点插入到以 root 为根节点的二叉树中")]),t._v("\n            self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("insertNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 当 preorder 中所有元素都构造并且插入完毕之后")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 二叉树就完成了构建")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" root\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# root : 二叉树的根节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# node : 待插入的节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" root "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("dict")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 当 root 和 node 指向的节点相同时，跳出循环")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果 node 的中序遍历序列位置小于 root 的中序遍历序列位置")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 说明 node 应该在 root 的左子树中")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果此时 root 没有左子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么就把 node 设置为 root 的左子树")]),t._v("\n                        root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node\n                    \n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1、如果之前 root 没有左子树，那么通过上面的代码，就设置好了 root 的左子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 也就是说 node 是 root 的一个叶子节点，完成了插入操作")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把 root 指向 root.left 后，root 为 node，跳出了循环")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2、如果之前 root 已经有左子树，那么就不能直接把 node 插入到 root 的左子树上")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 需要判断应该把 node 插入到 root 左子树上的孩子节点的那个位置上")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 比如现在的 root 是这个样子，node 为 A")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#        G")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#       /")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#      D")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#     /  \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#    ①   ②")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# root 已经有左子树 D 了，所以 node 应该考虑插入到 D 中的 ① 还是 ② 上面")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 所以，把 root 指向 root.left ，继续遍历 root 的左子树的情况")]),t._v("\n                    root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left\n\n                    \n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果 node 的中序遍历序列位置大于 root 的中序遍历序列位置")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 说明 node 应该在 root 的右子树中")]),t._v("\n                    \n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果此时 root 没有右子树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么就把 node 设置为 root 的右子树")]),t._v("\n                        root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node\n                    \n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把 root 指向 root.right ，继续遍历 root 的右子树的情况")]),t._v("\n                    root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);