(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{540:function(t,s,n){"use strict";n.r(s);var a=n(54),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"leetcode-206、反转链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-206、反转链表"}},[t._v("#")]),t._v(" LeetCode 206、反转链表")]),t._v(" "),n("h2",{attrs:{id:"一、题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),n("strong",[t._v("一、题目描述")])]),t._v(" "),n("p",[t._v("给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://superblog-1257126549.cos.ap-guangzhou.myqcloud.com/202306111033459.(null)",alt:"img"}})]),t._v(" "),n("h2",{attrs:{id:"二、题目解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("二、题目解析")])]),t._v(" "),n("p",[t._v("这道题目有很多种解法，递归解法最难以理解整个过程，今天我就带大家来探究一次！")]),t._v(" "),n("p",[t._v("先来看分析过程，这里看不懂没关系，一定要看最后的"),n("strong",[t._v("动画过程")]),t._v("。")]),t._v(" "),n("ul",[n("li",[t._v("1、通过"),n("strong",[t._v("递归函数")]),t._v("，一直递归到链表的最后一个结点为止，此时，"),n("strong",[t._v("该结点就是反转成功后的头结点")]),t._v("，是最终的返回结果。")]),t._v(" "),n("li",[t._v("2、在递归函数中，让当前节点的下一个节点的 "),n("code",[t._v("next")]),t._v(" 指针指向当前节点。")]),t._v(" "),n("li",[t._v("3、在递归函数中，让当前节点的 "),n("code",[t._v("next")]),t._v(" 指针指向 "),n("code",[t._v("null")])]),t._v(" "),n("li",[t._v("4、通过二三步的操作，已经让递归函数中的链表实现了"),n("strong",[t._v("局部反转")]),t._v("，将结果返回给上一层递归函数")]),t._v(" "),n("li",[t._v("5、所有递归结束后，链表反转成功。")])]),t._v(" "),n("h2",{attrs:{id:"三、参考代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("三、参考代码")])]),t._v(" "),n("h3",{attrs:{id:"_1、java-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("1、Java 代码")])]),t._v(" "),n("div",{staticClass:"language-Java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverseList")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 寻找递归终止条件")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、head 指向的结点为 null ")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、head 指向的结点的下一个结点为 null ")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在这两种情况下，反转之后的结果还是它自己本身")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" head "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListNode")]),t._v(" cur "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverseList")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如原链表为 1 --\x3e 2 --\x3e 3 --\x3e 4 --\x3e 5")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等号右侧为 head，意思就是设置 5 的下一个节点是 4")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里出现了两个 next")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一个 next 是「获取」 head 的下一节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值")]),t._v("\n  head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 否则会发生无限循环")]),t._v("\n  head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们把每次反转后的结果传递给上一层")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" cur"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"_2、-c-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、-c-代码"}},[t._v("#")]),t._v(" **2、**"),n("strong",[t._v("C++")]),t._v(" "),n("strong",[t._v("代码")])]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 登录 AlgoMooc 官网获取更多算法图解\n// https://www.algomooc.com\n// 作者：程序员吴师兄\n// 代码有看不懂的地方一定要私聊咨询吴师兄呀\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n  // 寻找递归终止条件\n        // 1、head 指向的结点为 null \n        // 2、head 指向的结点的下一个结点为 null \n        // 在这两种情况下，反转之后的结果还是它自己本身\n  if( head == NULL || head->next == NULL)  return head;\n\n        // 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点\n        // 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head\n  ListNode *cur = reverseList(head->next);\n\n        // 比如原链表为 1 --\x3e 2 --\x3e 3 --\x3e 4 --\x3e 5\n        // 第一次执行下面代码的时候，head 为 4，那么 head.next = 5\n        // 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点\n        // 等号右侧为 head，意思就是设置 5 的下一个节点是 4\n        \n        // 这里出现了两个 next\n        // 第一个 next 是「获取」 head 的下一节点\n        // 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值\n  head->next->next = head;\n\n\n  // head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了\n        // 否则会发生无限循环\n  head->next = nullptr;\n\n  // 我们把每次反转后的结果传递给上一层\n  return cur;\n\n    }\n};\n")])])]),n("h3",{attrs:{id:"_3、python-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("3、Python 代码")])]),t._v(" "),n("div",{staticClass:"language-Python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  https://www.algomooc.com")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  作者：程序员吴师兄")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverseList")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v('"""\n  :type head: ListNode\n  :rtype: ListNode\n  """')]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 寻找递归终止条件")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1、head 指向的结点为 null ")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2、head 指向的结点的下一个结点为 null ")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在这两种情况下，反转之后的结果还是它自己本身")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("or")]),t._v(" head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" head\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head")]),t._v("\n  cur "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("reverseList"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 比如原链表为 1 --\x3e 2 --\x3e 3 --\x3e 4 --\x3e 5")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 第一次执行下面代码的时候，head 为 4，那么 head.next = 5")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 等号右侧为 head，意思就是设置 5 的下一个节点是 4")]),t._v("\n        \n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这里出现了两个 next")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 第一个 next 是「获取」 head 的下一节点")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值")]),t._v("\n  head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 否则会发生无限循环")]),t._v("\n  head"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("next")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 我们把每次反转后的结果传递给上一层")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" cur\n")])])]),n("h2",{attrs:{id:"四、复杂度分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、复杂度分析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("四、复杂度分析")])]),t._v(" "),n("p",[t._v("时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。")]),t._v(" "),n("p",[t._v("空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。")])])}),[],!1,null,null,null);s.default=e.exports}}]);