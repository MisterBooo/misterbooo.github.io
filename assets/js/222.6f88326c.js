(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{607:function(t,s,a){"use strict";a.r(s);var n=a(54),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"剑指-offer-09-用两个栈实现队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#剑指-offer-09-用两个栈实现队列"}},[t._v("#")]),t._v(" 剑指 Offer 09. 用两个栈实现队列")]),t._v(" "),a("p",[t._v("大家好，我是吴师兄。")]),t._v(" "),a("p",[t._v("今天继续来学习《剑指Offer》系列的一道经典题目，依旧给出了非常详细的题解和精美的配图与动画。")]),t._v(" "),a("h2",{attrs:{id:"一、题目描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" 一、题目描述")]),t._v(" "),a("p",[a("strong",[t._v("用两个栈实现一个队列")]),t._v("。队列的声明如下，请实现它的两个函数 "),a("code",[t._v("appendTail")]),t._v(" 和 "),a("code",[t._v("deleteHead")]),t._v(" ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，"),a("code",[t._v("deleteHead")]),t._v(" 操作返回 "),a("code",[t._v("-1")]),t._v(" )")]),t._v(" "),a("p",[a("strong",[t._v("示例 1：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('输入：\n["CQueue","appendTail","deleteHead","deleteHead"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n')])])]),a("p",[a("strong",[t._v("示例 2：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('输入：\n["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n')])])]),a("p",[a("strong",[t._v("提示：")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("1 <= values <= 10000")])]),t._v(" "),a("li",[a("code",[t._v("最多会对 appendTail、deleteHead 进行 10000 次调用")])])]),t._v(" "),a("h2",{attrs:{id:"二、题目解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" 二、题目解析")]),t._v(" "),a("p",[t._v("首先，我们来复习一下栈和队列的特点。")]),t._v(" "),a("p",[a("strong",[t._v("1、栈是一个先进后出的线性表")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("2、队列是一个先进先出的线性表")]),t._v("。")]),t._v(" "),a("p",[t._v("根据这两个特点，如果说想让栈实现队列的"),a("strong",[t._v("先进先出")]),t._v("的功能，必须得先将栈中最开始进入的元素"),a("strong",[t._v("栈底元素")]),t._v("第一个出栈，但由于上方有很多其它元素，无法出栈，所以第一步是需要将上方所有元素先出栈。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/szoxw.png",alt:"图1"}})]),t._v(" "),a("p",[t._v("如图 1 所示，5 比 2 更早的加入到栈中，因此想要实现队列的"),a("strong",[t._v("先进先出")]),t._v("的功能，5 应该比 2 更早的出栈，但它的上方有个其它元素 2。")]),t._v(" "),a("p",[t._v("因此，需要先将栈 stack1 中的元素逐个出栈加入到栈 stack2 中，这样原先 stack1 中的栈底元素变成了 stack2 中的栈顶元素，5 可以比后面加入的 2 更早的出栈，实现了队列的"),a("strong",[t._v("先进先出")]),t._v("的功能。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/ijvj3.png",alt:"图 2"}})]),t._v(" "),a("p",[t._v("接下来，再具体解析一下题目描述中所给的示例的含义。")]),t._v(" "),a("h4",{attrs:{id:"_1、cqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、cqueue"}},[t._v("#")]),t._v(" 1、CQueue")]),t._v(" "),a("p",[t._v("首先初始化，没有参数，所以是 []，然后我们注意到 CQueue() 函数是没有返回值的，用 null 来表示（不要问我为什么用 null 表示。。。）")]),t._v(" "),a("h4",{attrs:{id:"_2、deletehead"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、deletehead"}},[t._v("#")]),t._v(" 2、deleteHead")]),t._v(" "),a("p",[t._v("删除操作，没有参数，所以是 []，根据题意若队列中没有元素，deleteHead 操作返回 -1 ，所以输出值为 -1 。")]),t._v(" "),a("h4",{attrs:{id:"_3、appendtail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、appendtail"}},[t._v("#")]),t._v(" 3、appendTail")]),t._v(" "),a("p",[t._v("插入操作，有参数，此时是 **5 **，并且 appendTail() 函数没有返回值的，用 null 来表示。")]),t._v(" "),a("h4",{attrs:{id:"_4、appendtail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、appendtail"}},[t._v("#")]),t._v(" 4、appendTail")]),t._v(" "),a("p",[t._v("插入操作，有参数，此时是 **2 **，并且 appendTail() 函数没有返回值的，用 null 来表示。")]),t._v(" "),a("h4",{attrs:{id:"_5、deletehead"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、deletehead"}},[t._v("#")]),t._v(" 5、deleteHead")]),t._v(" "),a("p",[t._v("删除操作，没有参数，所以是 []，此时队列中有元素，先进入的是 5，后进入的是 2，根据队列"),a("strong",[t._v("先进先出")]),t._v("的性质，元素 5 出列，所以返回值是 5 。")]),t._v(" "),a("h4",{attrs:{id:"_6、deletehead"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、deletehead"}},[t._v("#")]),t._v(" 6、deleteHead")]),t._v(" "),a("p",[t._v("删除操作，没有参数，所以是 []，此时队列中有元素，只有元素 2，所以返回值是 2 。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("基本上看完上面的大白话翻译就可以理解题意，解决问题也不难了。")]),t._v(" "),a("h4",{attrs:{id:"入队操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入队操作"}},[t._v("#")]),t._v(" 入队操作")]),t._v(" "),a("p",[t._v("如果是栈的插入操作，那我们可以把元素都先插入到 stack1 中，也就实现了队列的 入队操作 。")]),t._v(" "),a("h4",{attrs:{id:"出队操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#出队操作"}},[t._v("#")]),t._v(" 出队操作")]),t._v(" "),a("ul",[a("li",[t._v("当 stack2 中不为空时，直接操作，此时在 stack2 中的栈顶元素是最先进入队列的元素，返回该元素即可；")]),t._v(" "),a("li",[t._v("如果 stack2 为空且 stack1 也为空，返回 -1；")]),t._v(" "),a("li",[t._v("如果 stack2 为空且 stack1 不为空，首先需要把 stack1 中的元素逐个弹出并压入到 stack2 中，然后返回 stack2 的栈顶元素即可。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/ff0y6.jpg",alt:"图 3"}})]),t._v(" "),a("p",[t._v("为了帮助你更好的理解整个过程，我特意做了一组动画，"),a("strong",[t._v("点开可以查看")]),t._v("：")]),t._v(" "),a("video",{attrs:{id:"video",width:"700",height:"400",muted:"muted",controls:"controls",poster:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/3hdi5.jpeg"},domProps:{muted:!0}},[a("source",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/MP4/myoffer009_Github.m4v",type:"video/mp4"}})]),t._v(" "),a("h2",{attrs:{id:"三、参考代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" 三、参考代码")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀，微信 wzb_3377")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Java 中的 Stack 类设计有问题，大部分情况下是使用 LinkedList 来构建栈，但为了结合动画更好的理解这道题目，所以依旧使用 Stack ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CQueue")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 队列的特点，先进先出")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 栈的特点是先进后出")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建两个栈")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建栈 stack1 用来充当队列")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" stack1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建栈 stack2 用来辅助 stack1 执行队列的一些复杂操作")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" stack2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个函数是 creat queue")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 意思就是初始化队列")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于题目要求我们用两个栈实现队列，所以在这个函数中初始化的是两个栈")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CQueue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化 stack1 ")]),t._v("\n        stack1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化 stack2 ")]),t._v("\n        stack2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个函数的意思是在队列的尾部添加元素")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用栈来完成这个操作的话就是在 stack1 的后面添加元素就行")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendTail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 直接将元素存放到 stack1 中")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如原队列为")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       -------------")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  队尾  1  2  3  4  5  队头")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       -------------")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前 value 为 6 ")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么由 stack1 和 stack2 组成的队列就是")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       ----------------")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  队尾  6  1  2  3  4  5  队头")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       ----------------")]),t._v("\n        stack1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个函数的意思是在队列的头部删除元素")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于队列的特点是先进先出，所以需要借助 stack1 和 stack2 去定位到之前存储进来的元素")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteHead")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、如果 stack2 栈不为空，说明 stack2 里面已经存储了一些元素，")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 并且 stack2 的栈顶元素就是两个栈中最早加入的元素")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("stack2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回 stack2 的栈顶元素，满足了队列先进先出的特点")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" stack2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、如果 stack2 为空，并且发现 stack1 也为空，")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 说明 stack1 和 stack2 构建的队列中没有元素，")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stack1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根据题意，直接返回 -1")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3、如果 stack2 为空，但 stack1 不为空")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么需要先将 stack1 中的元素依次【倒序】放入 stack2 中")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对于 stack1 来说，越早加入的元素在【栈底】，越晚加入的元素在【栈顶】")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于队列是【先进先出】，所以删除的应该是 stack1 的【栈底】元素")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("stack1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取 stack1 的栈顶元素并将该元素从 stack1 中弹出")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" topValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stack1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把该元素加入到 stack2")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这样 stack2 的栈顶元素就是 stack1 的栈底元素")]),t._v("\n            stack2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("topValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 4、返回 stack2 的栈顶元素，满足了队列先进先出的特点")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" stack2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);