(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{408:function(t,s,n){"use strict";n.r(s);var a=n(54),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"leetcode-71、简化路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-71、简化路径"}},[t._v("#")]),t._v(" LeetCode 71、简化路径")]),t._v(" "),n("h2",{attrs:{id:"一、题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),n("strong",[t._v("一、题目描述")])]),t._v(" "),n("p",[t._v("给你一个字符串 "),n("code",[t._v("path")]),t._v(" ，表示指向某一文件或目录的 Unix 风格 "),n("strong",[t._v("绝对路径")]),t._v(" （以 "),n("code",[t._v("'/'")]),t._v(" 开头），请你将其转化为更加简洁的规范路径。")]),t._v(" "),n("p",[t._v("在 Unix 风格的文件系统中，一个点（"),n("code",[t._v(".")]),t._v("）表示当前目录本身；此外，两个点 （"),n("code",[t._v("..")]),t._v("） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，"),n("code",[t._v("'//'")]),t._v("）都被视为单个斜杠 "),n("code",[t._v("'/'")]),t._v(" 。 对于此问题，任何其他格式的点（例如，"),n("code",[t._v("'...'")]),t._v("）均被视为文件/目录名称。")]),t._v(" "),n("p",[t._v("请注意，返回的 "),n("strong",[t._v("规范路径")]),t._v(" 必须遵循下述格式：")]),t._v(" "),n("ul",[n("li",[t._v("始终以斜杠 "),n("code",[t._v("'/'")]),t._v(" 开头。")]),t._v(" "),n("li",[t._v("两个目录名之间必须只有一个斜杠 "),n("code",[t._v("'/'")]),t._v(" 。")]),t._v(" "),n("li",[t._v("最后一个目录名（如果存在）"),n("strong",[t._v("不能")]),t._v(" 以 "),n("code",[t._v("'/'")]),t._v(" 结尾。")]),t._v(" "),n("li",[t._v("此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 "),n("code",[t._v("'.'")]),t._v(" 或 "),n("code",[t._v("'..'")]),t._v("）。")])]),t._v(" "),n("p",[t._v("返回简化后得到的 "),n("strong",[t._v("规范路径")]),t._v(" 。")]),t._v(" "),n("p",[n("strong",[t._v("示例 1：")])]),t._v(" "),n("p",[t._v("输入："),n("code",[t._v('path = "/home/"')]),t._v(" 输出："),n("code",[t._v('"/home"')]),t._v(" 解释：注意，最后一个目录名后面没有斜杠。")]),t._v(" "),n("p",[n("strong",[t._v("示例 2：")])]),t._v(" "),n("p",[t._v("输入："),n("code",[t._v('path = "/../"')]),t._v(" 输出："),n("code",[t._v('"/"')]),t._v(" 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。")]),t._v(" "),n("p",[n("strong",[t._v("示例 3：")])]),t._v(" "),n("p",[t._v("输入："),n("code",[t._v('path = "/home//foo/"')]),t._v(" 输出："),n("code",[t._v('"/home/foo"')]),t._v(" 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。")]),t._v(" "),n("p",[n("strong",[t._v("示例 4：")])]),t._v(" "),n("p",[t._v("输入："),n("code",[t._v('path = "/a/./b/../../c/"')]),t._v(" 输出："),n("code",[t._v('"/c"')])]),t._v(" "),n("p",[n("strong",[t._v("提示：")])]),t._v(" "),n("ul",[n("li",[n("code",[t._v("1 <= path.length <= 3000")])]),t._v(" "),n("li",[n("code",[t._v("path")]),t._v(" 由英文字母，数字，"),n("code",[t._v("'.'")]),t._v("，"),n("code",[t._v("'/'")]),t._v(" 或 "),n("code",[t._v("'_'")]),t._v(" 组成。")]),t._v(" "),n("li",[n("code",[t._v("path")]),t._v(" 是一个有效的 Unix 风格绝对路径。")])]),t._v(" "),n("h2",{attrs:{id:"二、题目解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("二、题目解析")])]),t._v(" "),n("p",[t._v("我们首先将给定的字符串  path 根据 / 分割成一个由若干字符串组成的列表，记为 names。根据题目中规定的「规范路径的下述格式」，names 中包含的字符串只能为以下几种：")]),t._v(" "),n("p",[t._v("1、空字符串。例如当出现多个连续的 /，就会分割出空字符串；")]),t._v(" "),n("p",[t._v("2、一个点  .；")]),t._v(" "),n("p",[t._v("3、两个点 ..；")]),t._v(" "),n("p",[t._v("4.只包含英文字母、数字或 _ 的目录名。")]),t._v(" "),n("p",[t._v("对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。")]),t._v(" "),n("p",[t._v("对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。")]),t._v(" "),n("p",[t._v("这样一来，我们只需要遍历names 中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 / 进行连接，再在最前面加上/ 表示根目录，就可以得到简化后的规范路径。")]),t._v(" "),n("h2",{attrs:{id:"三、参考代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("三、参考代码")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Solution {\npublic:\n    string simplifyPath(string path) {\n\n        // 分割字符串为列表形式\n        std::vector<std::string> names;\n        std::stringstream ss(path);\n        std::string name;\n        \n        while (getline(ss, name, \'/\')) {\n            names.push_back(name);\n        }\n\n        // 利用栈来处理\n        std::vector<std::string> stack;\n\n        // 访问列表里面的元素\n        for (const auto& name : names) {\n            std::cout << name << std::endl;\n            // 1、如果是 ..\n            if (name == "..") {\n                // 在栈不为空的情况下\n                if (!stack.empty()) {\n                    // 弹出栈顶元素\n                    stack.pop_back();\n                }\n            }\n            // 2、如果是有效值\n            // 字母\n            else if (!name.empty() && name != ".") {\n                stack.push_back(name);\n            }\n        }\n\n        std::stringstream result;\n        result << "/";\n        for (size_t i = 0; i < stack.size(); ++i) {\n            result << stack[i];\n            if (i != stack.size() - 1) {\n                result << "/";\n            }\n        }\n\n        return result.str();\n\n    }\n};\n')])])]),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("simplifyPath")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" path"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("str")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("str")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 分割字符串为列表形式")]),t._v("\n        names "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" path"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("split"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 利用栈来处理")]),t._v("\n        stack "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 访问列表里面的元素")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" names"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1、如果是 .. ")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('".."')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在栈不为空的情况下")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" stack"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 弹出栈顶元素")]),t._v("\n                    stack"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2、如果是有效值")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 字母")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("and")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                stack"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# stack = ['Python', 'World', 'Hello']")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# new_string = '/ '.join(stack)")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# print(new_string)")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出结果 Python/ World/ Hello")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 我们使用/ 作为分隔符，将栈stack中的元素连接成一个新的字符串。")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 每个元素之间使用/ 进行分隔，因此输出结果中每个元素都以/ 结尾（除了最后一个元素）。")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("join"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stack"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);