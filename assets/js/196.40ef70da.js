(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{582:function(t,s,n){"use strict";n.r(s);var a=n(54),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"leetcode-278、第一个错误版本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-278、第一个错误版本"}},[t._v("#")]),t._v(" LeetCode 278、第一个错误版本")]),t._v(" "),n("h2",{attrs:{id:"一、题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),n("strong",[t._v("一、题目描述")])]),t._v(" "),n("p",[t._v("你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。")]),t._v(" "),n("p",[t._v("假设你有 n 个版本 [1, 2, ..., n]，"),n("strong",[t._v("你想找出导致之后所有版本出错的第一个错误的版本")]),t._v("。")]),t._v(" "),n("p",[t._v("你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。")]),t._v(" "),n("p",[n("strong",[t._v("示例 1：")])]),t._v(" "),n("div",{staticClass:"language-Plain extra-class"},[n("pre",{pre:!0,attrs:{class:"language-plain"}},[n("code",[t._v("输入：n = 5, bad = 4\n输出：4\n解释：调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true\n所以，4 是第一个错误的版本。\n")])])]),n("p",[n("strong",[t._v("提示：")])]),t._v(" "),n("ul",[n("li",[t._v("1 <= bad <= n <= 2(31) - 1")])]),t._v(" "),n("h2",{attrs:{id:"二、题目解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("二、题目解析")])]),t._v(" "),n("h2",{attrs:{id:"三、参考代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("三、参考代码")])]),t._v(" "),n("h3",{attrs:{id:"_1、java-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("1、Java 代码")])]),t._v(" "),n("div",{staticClass:"language-Java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一个错误的版本（ LeetCode 278 ）:https://leetcode-cn.com/problems/first-bad-version/")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VersionControl")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("firstBadVersion")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意到题目的第一个版本下标为 1 ，所以边界情况为 [ 1 , n ]")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用二分查找的方法，去定位出【第一个错误的版本】")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在 while 循环里面，left 不断的 ++，而 right 不断的 --")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当 left 和 right 相等， [ left , right ] 这个区间存在一个版本的时候")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个版本就是【第一个错误的版本】")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以，当 left == right 时，跳出循环")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时，while 循环的判断不可以使用等号")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" right"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// left + (right - left) / 2 和 (left + right) / 2 的结果相同")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是使用 left + (right - left) / 2 可以防止由于 left 、right 同时太大，导致相加的结果溢出的问题")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如数据 int 的最大值为 2,147,483,647")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时，left 为 2,147,483,640")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时，right 为 2,147,483,646")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 两者直接相加超过了 2,147,483,647，产生了溢出")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" mid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" left "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("right "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" left"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用系统函数，查看当前的版本是否是错误的版本")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1、如果当前版本为错误的版本，那么此时 mid 指向的版本有可能是【第一个错误的版本】")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 因此，区间缩小为 [ left , mid ]")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("isBadVersion")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mid"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再次注意，mid 指向的版本有可能是【第一个错误的版本】，因此，right 移动到 mid 的位置")]),t._v("\n                right "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mid"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2、如果当前版本为正确的版本，那么此时 mid 指向的版本绝对不可能是【第一个错误的版本】")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  因此，区间缩小为 [ mid + 1 , right ]")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                \n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再次注意，mid 指向的版本已经是正确的版本了")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 意味着 [ left , mid ] 的所有版本都是正确的，错误的版本发生在 [ mid + 1 , right ] 这个区间里面")]),t._v("\n                left "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mid "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当 left 和 right 相等， [ left , right ] 这个区间存在一个版本的时候")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个版本就是【第一个错误的版本】")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" left"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"_2、-c-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、-c-代码"}},[t._v("#")]),t._v(" **2、**"),n("strong",[t._v("C++")]),t._v(" "),n("strong",[t._v("代码")])]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Solution {\npublic:\n    int firstBadVersion(int n) {\n        // 注意到题目的第一个版本下标为 1 ，所以边界情况为 [ 1 , n ]\n        int left = 1 ;\n        int right = n ;\n\n        // 利用二分查找的方法，去定位出【第一个错误的版本】\n        // 在 while 循环里面，left 不断的 ++，而 right 不断的 --\n        // 当 left 和 right 相等， [ left , right ] 这个区间存在一个版本的时候\n        // 这个版本就是【第一个错误的版本】\n        // 所以，当 left == right 时，跳出循环\n        // 此时，while 循环的判断不可以使用等号\n        while (left < right) { \n            // left + (right - left) / 2 和 (left + right) / 2 的结果相同\n            // 但是使用 left + (right - left) / 2 可以防止由于 left 、right 同时太大，导致相加的结果溢出的问题\n            // 比如数据 int 的最大值为 2,147,483,647\n            // 此时，left 为 2,147,483,640\n            // 此时，right 为 2,147,483,646\n            // 两者直接相加超过了 2,147,483,647，产生了溢出\n            int mid = left + (right - left) / 2;\n\n            // 调用系统函数，查看当前的版本是否是错误的版本\n            // 1、如果当前版本为错误的版本，那么此时 mid 指向的版本有可能是【第一个错误的版本】\n            // 因此，区间缩小为 [ left , mid ]\n            if (isBadVersion(mid)) {\n\n                // 再次注意，mid 指向的版本有可能是【第一个错误的版本】，因此，right 移动到 mid 的位置\n                right = mid;\n\n            // 2、如果当前版本为正确的版本，那么此时 mid 指向的版本绝对不可能是【第一个错误的版本】\n            //  因此，区间缩小为 [ mid + 1 , right ]\n            } else {\n                \n                // 再次注意，mid 指向的版本已经是正确的版本了\n                // 意味着 [ left , mid ] 的所有版本都是正确的，错误的版本发生在 [ mid + 1 , right ] 这个区间里面\n                left = mid + 1; \n\n            }\n        }\n\n        // 当 left 和 right 相等， [ left , right ] 这个区间存在一个版本的时候\n        // 这个版本就是【第一个错误的版本】\n        return left;\n    }\n};\n")])])]),n("h3",{attrs:{id:"_3、python-代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),n("strong",[t._v("3、Python 代码")])]),t._v(" "),n("h2",{attrs:{id:"四、复杂度分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、复杂度分析"}},[t._v("#")]),t._v(" "),n("strong",[t._v("四、复杂度分析")])]),t._v(" "),n("p",[t._v("时间复杂度：O(logn)，其中 n 是给定版本的数量。")]),t._v(" "),n("p",[t._v("空间复杂度：O(1)。我们只需要常数的空间保存若干变量。")])])}),[],!1,null,null,null);s.default=e.exports}}]);