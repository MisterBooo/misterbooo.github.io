(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{557:function(t,n,s){"use strict";s.r(n);var a=s(54),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"leetcode-530、二叉搜索树的最小绝对差"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-530、二叉搜索树的最小绝对差"}},[t._v("#")]),t._v(" LeetCode 530、二叉搜索树的最小绝对差")]),t._v(" "),s("h2",{attrs:{id:"一、题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" "),s("strong",[t._v("一、题目描述")])]),t._v(" "),s("p",[t._v("给你一个二叉搜索树的根节点 "),s("code",[t._v("root")]),t._v(" ，返回 "),s("strong",[t._v("树中任意两不同节点值之间的最小差值")]),t._v(" 。")]),t._v(" "),s("p",[t._v("差值是一个正数，其数值等于两值之差的绝对值。")]),t._v(" "),s("h2",{attrs:{id:"二、题目解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" "),s("strong",[t._v("二、题目解析")])]),t._v(" "),s("h2",{attrs:{id:"三、参考代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("三、参考代码")])]),t._v(" "),s("h3",{attrs:{id:"_1、java-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1、Java 代码")])]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 二叉搜索树的最小绝对差（ LeetCode 530 ）: https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMinimumDifference")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个变量用来记录两不同节点值之间的差值")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MAX_VALUE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个栈，用来保存路径")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" stack "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stack")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个节点，一开始指向根节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置一个节点 preNode ，用来记录当前遍历节点的上一个节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" preNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置三种状态，方便表示当前遍历当前节点的时候进行到哪一步了")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 每个节点都有 左、右、上 这三种状态")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 按照 左 --\x3e 右 --\x3e 上 的顺序观察每个节点")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 左代表该节点的左右孩子节点都没有遍历")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nodeLeft "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nodeRight "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上代表左右孩子节点都已经遍历，需要返回到它的父节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nodeUp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("300")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 每个节点的初始化状态都是从 左 开始")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeLeft"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对二叉树进行遍历")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 位置 ① ")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeLeft"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点有左子树")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 先把当前节点加入到栈中，用来记录节点移动的路径")]),t._v("\n                    stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开始观察当前节点的左孩子节点，代码来到了位置 ① ")]),t._v("\n                    curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点没有左子树，切换当前节点的状态为【右】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码来到了位置 ① ")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeRight"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeRight"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 二叉树中序遍历的处理结果")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("preNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" preNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n                preNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点有右子树")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 先把当前节点加入到栈中，用来记录节点移动的路径")]),t._v("\n                    stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开始观察当前节点的右孩子节点")]),t._v("\n                    curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeLeft"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行完上面三行代码，代码来到了位置 ①     ")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点没有右子树，切换当前节点的状态为【上】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码来到了位置 ①")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeUp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeUp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 首先构建一个空的节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),t._v(" parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果栈中有元素")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么，栈顶元素就是当前节点的父节点")]),t._v("\n                    parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断一下父节点的左节点是否为当前节点")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如这颗二叉树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//           1")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         /   \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        2     3")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       / \\     \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//      4   5     6")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  如果当前节点是 5 ，那么 5 的父节点是 2，2 的左孩子节点是 4，此时不需要切换状态")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果父节点的左节点为当前节点")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 切换当前节点的状态为【右】")]),t._v("\n                        nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeRight"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开始观察当前节点的父节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果上述代码中栈中有元素，那么 parent 有值，代码来到了位置 ①")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环")]),t._v("\n                curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回结果")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_2、-c-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、-c-代码"}},[t._v("#")]),t._v(" **2、**"),s("strong",[t._v("C++")]),t._v(" "),s("strong",[t._v("代码")])]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 登录 AlgoMooc 官网获取更多算法图解\n// https://www.algomooc.com\n// 作者：程序员吴师兄\n// 代码有看不懂的地方一定要私聊咨询吴师兄呀\n// 二叉搜索树的最小绝对差（ LeetCode 530 ）: https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/\nclass Solution\n{\npublic:\n    int getMinimumDifference(TreeNode* root)\n    {\n\n        // 设置一个变量用来记录两不同节点值之间的差值\n        int result = INT_MAX;\n\n        // 设置一个栈，用来保存路径\n        stack<TreeNode*> st;\n\n        // 设置一个节点，一开始指向根节点\n        TreeNode* curNode = root;\n\n        // 设置一个节点 preNode ，用来记录当前遍历节点的上一个节点\n        TreeNode* preNode = NULL;\n\n        // 设置三种状态，方便表示当前遍历当前节点的时候进行到哪一步了\n        // 每个节点都有 左、右、上 这三种状态\n        // 按照 左 --\x3e 右 --\x3e 上 的顺序观察每个节点\n\n        // 左代表该节点的左右孩子节点都没有遍历\n        int nodeLeft = 100;\n\n        // 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历\n        int nodeRight = 200;\n\n        // 上代表左右孩子节点都已经遍历，需要返回到它的父节点\n        int nodeUp = 300;\n\n        // 每个节点的初始化状态都是从 左 开始\n        int nodeState = nodeLeft;\n\n        // 对二叉树进行遍历\n        while (curNode != NULL)\n        {\n\n            // 位置 ①\n\n            // 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历\n            if (nodeState == nodeLeft)\n            {\n\n                // 如果当前节点有左子树\n                if (curNode->left != NULL)\n                {\n\n                    // 先把当前节点加入到栈中，用来记录节点移动的路径\n                    st.push(curNode);\n\n                    // 开始观察当前节点的左孩子节点，代码来到了位置 ①\n                    curNode = curNode->left;\n                }\n                else\n                {\n\n                    // 如果当前节点没有左子树，切换当前节点的状态为【右】\n                    // 代码来到了位置 ①\n                    nodeState = nodeRight;\n                }\n            }\n            else if (nodeState == nodeRight)\n            { // 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历\n\n                // 二叉树中序遍历的处理结果\n                if (preNode != NULL)\n                {\n                    result = min(result, curNode->val - preNode->val);\n                }\n\n                preNode = curNode;\n\n                // 如果当前节点有右子树\n                if (curNode->right != NULL)\n                {\n\n                    // 先把当前节点加入到栈中，用来记录节点移动的路径\n                    st.push(curNode);\n\n                    // 开始观察当前节点的右孩子节点\n                    curNode = curNode->right;\n\n                    // 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态\n                    nodeState = nodeLeft;\n\n                    // 执行完上面三行代码，代码来到了位置 ①\n                }\n                else\n                {\n                    // 如果当前节点没有右子树，切换当前节点的状态为【上】\n                    // 代码来到了位置 ①\n                    nodeState = nodeUp;\n                }\n            }\n            else if (nodeState == nodeUp)\n            { // 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点\n\n                // 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点\n                // 首先构建一个空的节点\n                TreeNode* parent = NULL;\n\n                // 如果栈中有元素\n                if (!st.empty())\n                {\n\n                    // 那么，栈顶元素就是当前节点的父节点\n                    parent = st.top(); \n                    st.pop();\n\n                    // 判断一下父节点的左节点是否为当前节点\n                    // 比如这颗二叉树\n                    //           1\n                    //         /   \\\n                    //        2     3\n                    //       / \\     \\\n                    //      4   5     6\n                    //  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】\n                    //  如果当前节点是 5 ，那么 5 的父节点是 2，2 的左孩子节点是 4，此时不需要切换状态\n\n                    // 如果父节点的左节点为当前节点\n                    if (parent->left == curNode)\n                    {\n                        // 切换当前节点的状态为【右】\n                        nodeState = nodeRight;\n                    }\n                }\n                // 开始观察当前节点的父节点\n                // 如果上述代码中栈中有元素，那么 parent 有值，代码来到了位置 ①\n                // 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环\n                curNode = parent;\n            }\n        }\n        // 返回结果\n        return result;\n    }\n};\n")])])]),s("h3",{attrs:{id:"_3、python-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、python-代码"}},[t._v("#")]),t._v(" "),s("strong",[t._v("3、Python 代码")])]),t._v(" "),s("div",{staticClass:"language-Python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("登录 AlgoMooc 官网获取更多算法图解\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# https://www.algomooc.com")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 作者：程序员吴师兄")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 二叉搜索树的最小绝对差（ LeetCode 530 ）: https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMinimumDifference")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TreeNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个数组用来保存二叉树前序遍历的结果")]),t._v("\n        result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100000")]),t._v("\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个栈，用来保存路径")]),t._v("\n        stack "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个节点，一开始指向根节点")]),t._v("\n        curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" root\n\n       \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置一个节点 preNode ，用来记录当前遍历节点的上一个节点")]),t._v("\n\n        preNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置三种状态，方便表示当前遍历当前节点的时候进行到哪一步了")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 每个节点都有 左、右、上 这三种状态")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 按照 左 --\x3e 右 --\x3e 上 的顺序观察每个节点")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 左代表该节点的左右孩子节点都没有遍历")]),t._v("\n        nodeLeft "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历")]),t._v("\n        nodeRight "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 上代表左右孩子节点都已经遍历，需要返回到它的父节点")]),t._v("\n        nodeUp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("300")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 每个节点的初始化状态都是从 左 开始")]),t._v("\n        nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeLeft\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 对二叉树进行遍历")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" curNode "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 位置 ① ")]),t._v("\n\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeLeft "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n               \n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点有左子树")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先把当前节点加入到栈中，用来记录节点移动的路径")]),t._v("\n                    stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开始观察当前节点的左孩子节点，代码来到了位置 ① ")]),t._v("\n                    curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点没有左子树，切换当前节点的状态为【右】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 代码来到了位置 ① ")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeRight\n\n\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeRight"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" preNode "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                   result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("min")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" preNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n                preNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点有右子树")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先把当前节点加入到栈中，用来记录节点移动的路径")]),t._v("\n                    stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开始观察当前节点的右孩子节点")]),t._v("\n                    curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeLeft\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 执行完上面三行代码，代码来到了位置 ①     ")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点没有右子树，切换当前节点的状态为【上】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 代码来到了位置 ①")]),t._v("\n                    nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeUp\n\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nodeUp "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 把当前节点加入到二叉树后序遍历的结果数组中")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# postorderResult.add(node.val)")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 首先构建一个空的节点")]),t._v("\n                parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果栈中有元素")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" stack "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 那么，栈顶元素就是当前节点的父节点")]),t._v("\n                    parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 判断一下父节点的左节点是否为当前节点")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 比如这颗二叉树")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#           1")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#         /   \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#        2     3")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#       / \\     \\")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#      4   5     6")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#  如果当前节点是 5 ，那么 5 的父节点是 2，2 的左孩子节点是 4，此时不需要切换状态")]),t._v("\n\n                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果父节点的左节点为当前节点")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" curNode "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 切换当前节点的状态为【右】")]),t._v("\n                        nodeState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nodeRight\n\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开始观察当前节点的父节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果上述代码中栈中有元素，那么 parent 有值，代码来到了位置 ①")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环")]),t._v("\n                curNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent\n\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 根据题目要求，返回二叉树前序、中序、后序遍历的结果")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);