(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{623:function(t,s,a){"use strict";a.r(s);var n=a(54),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"剑指-offer-33-二叉搜索树的后序遍历序列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#剑指-offer-33-二叉搜索树的后序遍历序列"}},[t._v("#")]),t._v(" 剑指 Offer 33. 二叉搜索树的后序遍历序列")]),t._v(" "),a("p",[t._v("大家好，我是吴师兄。")]),t._v(" "),a("p",[t._v("今天继续来学习《剑指Offer》系列的一道经典题目，依旧给出了非常详细的题解和精美的配图与动画。")]),t._v(" "),a("h2",{attrs:{id:"一、题目描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、题目描述"}},[t._v("#")]),t._v(" 一、题目描述")]),t._v(" "),a("p",[t._v("输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 "),a("code",[t._v("true")]),t._v("，否则返回 "),a("code",[t._v("false")]),t._v("。假设输入的数组的任意两个数字都互不相同。")]),t._v(" "),a("p",[t._v("参考以下这颗二叉搜索树：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("     5\n    / \\\n   2   6\n  / \\\n 1   3\n")])])]),a("p",[a("strong",[t._v("示例 1：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("输入: [1,6,3,2,5]\n输出: false\n")])])]),a("p",[a("strong",[t._v("示例 2：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("输入: [1,3,2,6,5]\n输出: true\n")])])]),a("p",[a("strong",[t._v("提示：")])]),t._v(" "),a("ol",[a("li",[a("code",[t._v("数组长度 <= 1000")])])]),t._v(" "),a("h2",{attrs:{id:"二、题目解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、题目解析"}},[t._v("#")]),t._v(" 二、题目解析")]),t._v(" "),a("p",[t._v("这道题目首先得掌握以下基础概念：")]),t._v(" "),a("ul",[a("li",[t._v("1、二叉搜索树")]),t._v(" "),a("li",[t._v("2、后序遍历的递归写法")])]),t._v(" "),a("p",[t._v("二叉搜索树是一棵"),a("strong",[t._v("有序")]),t._v("的二叉树，它具有如下的性质：")]),t._v(" "),a("ul",[a("li",[t._v("1、若它的左子树不为空，那么左子树上的所有值均小于它的根节点")]),t._v(" "),a("li",[t._v("2、若它的右子树不为空，那么右子树上所有值均大于它的根节点")]),t._v(" "),a("li",[t._v("3、它的左子树和右子树也都是二叉搜索树")])]),t._v(" "),a("p",[t._v("而后序遍历的递归过程是 "),a("strong",[t._v("左 ---》右 ---》根")]),t._v(" 的顺序。")]),t._v(" "),a("p",[t._v("比如对于下面这棵二叉搜索树来说，它的后序遍历序列是 "),a("code",[t._v("[4, 8, 6, 12, 16, 14, 10]")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/ocpug.png",alt:""}})]),t._v(" "),a("p",[t._v("由于后序遍历的过程中是不断的执行 "),a("strong",[t._v("左 ---》右 ---》根")]),t._v(" 的顺序，那也就意味着结果"),a("strong",[t._v("数组的最后一个数字必然是二叉搜索树的根节点")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/nt9nq.png",alt:""}})]),t._v(" "),a("p",[t._v("如果这个数组是二叉搜索树的后序遍历结果，那么在这个根节点 10 的前面既有它的左子树又有它的右子树，并且左右子树是扎堆出现的，即小于 10 的那些节点是连续排列的，大于 10 的那些节点也是连续排列的。")]),t._v(" "),a("p",[t._v("因此，我们可以从头到尾去遍历 10 前面的数字，找到"),a("strong",[t._v("第一个大于 10 的位置")]),t._v("，这个位置前面的数都小于了 10 ，是它的左子树，这个位置后面的数都大于了 10，是它的右子树。")]),t._v(" "),a("p",[t._v("也就是如上图所示，划分为了青、黄、绿三个区域。")]),t._v(" "),a("p",[t._v("只要在黄色区域里面发现了小于 10 的值，那么就知道它"),a("strong",[t._v("不是二叉搜索树了")]),t._v("。")]),t._v(" "),a("p",[t._v("比如后序遍历序列 "),a("code",[t._v("[4, 8, 6, 12, 16, 9, 10]")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/et1kr.png",alt:""}})]),t._v(" "),a("p",[t._v("12 前面的都小于了 10 ，是 10 的左子树，12 后面的数字都是 10 的右子树，但对于二叉搜索树来说，右子树所有的节点都应该大于根节点的值，而 9 < 10 ，因此这棵二叉树不是二叉搜索树。")]),t._v(" "),a("p",[t._v("接下来，我们来看一下完整的操作：")]),t._v(" "),a("p",[t._v("1、获取数组最后一个节点的值，它是树的根节点，此时节点值为 10。")]),t._v(" "),a("p",[t._v("2、从头到尾遍历数组，直到遍历到第一个大于根节点 10 的值为止。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/8tzj6.png",alt:""}})]),t._v(" "),a("p",[t._v("3、遍历过程中，发现 12 这个节点是第一个大于根节点 10 的值。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/98myf.png",alt:""}})]),t._v(" "),a("p",[t._v("4、如果它是一棵二叉搜索树，那么从 12 开始，后面所有的节点值都应该大于 10，如果出现一个小于 10 的值，那么就不是二叉搜索树，直接返回 false 就行，否则，整个数组就被划分为三个区域。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/f9u2b.png",alt:""}})]),t._v(" "),a("p",[t._v("5、接下来，依次递归的判断左子树（青色区域）、右子树（黄色区域）是否也是二叉搜索树。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/5975v.png",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/y1ius.png",alt:""}})]),t._v(" "),a("p",[t._v("为了帮助你更好的理解整个过程，我特意做了一组动画，"),a("strong",[t._v("点开可以查看")]),t._v("：")]),t._v(" "),a("video",{attrs:{id:"video",width:"700",height:"400",muted:"muted",controls:"controls",poster:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/blog/3hdi5.jpeg"},domProps:{muted:!0}},[a("source",{attrs:{src:"https://article-1257126549.cos.ap-guangzhou.myqcloud.com/MP4/%E5%89%91%E6%8C%87%20Offer%2033.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.m4v",type:"video/mp4"}})]),t._v(" "),a("h2",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h2",{attrs:{id:"三、参考代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、参考代码"}},[t._v("#")]),t._v(" 三、参考代码")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 登录 AlgoMooc 官网获取更多算法图解")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// https://www.algomooc.com")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 作者：程序员吴师兄")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代码有看不懂的地方一定要私聊咨询吴师兄呀")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 剑指 Offer 33. 二叉搜索树的后序遍历序列：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Solution")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("verifyPostorder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" postorder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归的调用 isPostorder ，判断任意一棵子树是否是二叉搜索树")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPostorder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" postorder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" postorder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPostorder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" postorder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当 left >= right 时，说明当前区间只有一个节点或者没有节点了")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不需要在判断下去")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 先去后去当前区间最后一个节点的值")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于是后序遍历，即采取 左、右、根的顺序遍历")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 那么这个节点实际上是根节点")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" rootNodeValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" postorder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接下来，需要在这个区间里找出 rootNode 的左子树与右子树")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" firstRightNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从左到右遍历当前区间，找到第一个大于 rootNodeValue 的位置")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个位置前面的数都小于了 rootNodeValue ，是它的左子树")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个位置后面的数都大于了 rootNodeValue ，是它的右子树")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" postorder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("firstRightNodeIndex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" rootNodeValue "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            firstRightNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        \n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接下来判断从 firstRightNodeIndex 到 right 这个区间中，是否存在比 rootNodeValue 更小的值")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" curNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" firstRightNodeIndex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" curNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            curNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            \n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果发现从 firstRightNodeIndex 到 right 这个区间中存在比 rootNodeValue 更小的值")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根据二叉搜索树的性质，它的右子树的所有节点都必须大于根节点")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时，不符合这个性质，意味着这不是一棵二叉搜索树")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" postorder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("curNodeIndex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" rootNodeValue "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当代码执行到这里的时候，rootNode 的左子树值都小于了 rootNodeValue")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// rootNode 的右子树值都大于了 rootNodeValue")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接下来，递归的判断它的左子树、右子树是否是二叉搜索树")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPostorder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" postorder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" left "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" firstRightNodeIndex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n               "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" \n               "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPostorder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" postorder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" firstRightNodeIndex "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);